diff --git a/test/RebalanceBackendClient.test.js b/test/RebalanceBackendClient.test.js
index 8fa3111..7ab9855 100644
--- a/test/RebalanceBackendClient.test.js
+++ b/test/RebalanceBackendClient.test.js
@@ -12,6 +12,9 @@ describe('RebalanceBackendClient', () => {
   beforeEach(() => {
     originalEnv = { ...process.env };
     jest.clearAllMocks();
+    // Ensure external env does not override defaults for tests
+    delete process.env.REBALANCE_BACKEND_URL;
+    delete process.env.REBALANCE_BACKEND_TIMEOUT;
     client = new RebalanceBackendClient();
   });
 
diff --git a/test/SwapExecutionContext.test.js b/test/SwapExecutionContext.test.js
new file mode 100644
index 0000000..faa9aa5
--- /dev/null
+++ b/test/SwapExecutionContext.test.js
@@ -0,0 +1,85 @@
+const SwapExecutionContext = require('../src/valueObjects/SwapExecutionContext');
+
+describe('SwapExecutionContext', () => {
+  const baseParams = {
+    chainId: 1,
+    ethPrice: 3000,
+    userAddress: '0x1111111111111111111111111111111111111111',
+    toTokenAddress: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
+    toTokenDecimals: 18,
+  };
+
+  it('constructs with required fields and defaults', () => {
+    const ctx = new SwapExecutionContext({ ...baseParams, slippage: 1 });
+    expect(ctx.chainId).toBe(1);
+    expect(ctx.ethPrice).toBe(3000);
+    expect(ctx.toTokenDecimals).toBe(18);
+    expect(ctx.slippage).toBe(1);
+    expect(typeof ctx.createdAt).toBe('string');
+  });
+
+  it('throws for missing or invalid required fields', () => {
+    expect(() => new SwapExecutionContext({})).toThrow(/missing required fields/i);
+    expect(() => new SwapExecutionContext({ ...baseParams, chainId: 0 })).toThrow(/chainId/);
+    expect(() => new SwapExecutionContext({ ...baseParams, ethPrice: 0 })).toThrow(/ethPrice/);
+    expect(
+      () => new SwapExecutionContext({
+        ...baseParams,
+        userAddress: '0xBAD',
+      })
+    ).toThrow(/valid Ethereum address/);
+  });
+
+  it('fromExecutionContext fills defaults and maps props', () => {
+    const legacy = {
+      chainId: 1,
+      ethPrice: 2000,
+      userAddress: baseParams.userAddress,
+      toTokenPrice: 2100,
+      params: {},
+    };
+    const ctx = SwapExecutionContext.fromExecutionContext(legacy);
+    expect(ctx.toTokenAddress).toBe('0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee');
+    expect(ctx.toTokenDecimals).toBe(18);
+    expect(ctx.toTokenPrice).toBe(2100);
+  });
+
+  it('createSwapRequest maps token fields and context', () => {
+    const ctx = new SwapExecutionContext(baseParams);
+    const token = { address: '0xabc', decimals: 6, raw_amount: '123' };
+    const req = ctx.createSwapRequest(token);
+    expect(req).toMatchObject({
+      chainId: 1,
+      fromTokenAddress: '0xabc',
+      fromTokenDecimals: 6,
+      toTokenAddress: baseParams.toTokenAddress,
+      toTokenDecimals: 18,
+      fromAddress: baseParams.userAddress,
+      slippage: 0.5,
+      eth_price: 3000,
+    });
+  });
+
+  it('toLegacyFormat returns expected shape', () => {
+    const ctx = new SwapExecutionContext({ ...baseParams, slippage: 0.75, toTokenPrice: 3050 });
+    expect(ctx.toLegacyFormat()).toEqual({
+      chainId: 1,
+      ethPrice: 3000,
+      toTokenPrice: 3050,
+      userAddress: baseParams.userAddress,
+      toTokenAddress: baseParams.toTokenAddress,
+      toTokenDecimals: 18,
+      slippage: 0.75,
+    });
+  });
+
+  it('clone returns new instance with updates applied', () => {
+    const ctx = new SwapExecutionContext(baseParams);
+    const cloned = ctx.clone({ slippage: 2, metadata: { note: 'x' } });
+    expect(cloned).not.toBe(ctx);
+    expect(cloned.slippage).toBe(2);
+    expect(cloned.metadata).toEqual({ note: 'x' });
+    expect(cloned.userAddress).toBe(ctx.userAddress);
+  });
+});
+
diff --git a/test/app.test.js b/test/app.test.js
index 8782fe0..d73ccaa 100644
--- a/test/app.test.js
+++ b/test/app.test.js
@@ -16,6 +16,10 @@ jest.mock('../src/config/swaggerConfig', () => ({
 }));
 
 describe('App', () => {
+  // Clean up timers after each test to prevent Jest from hanging
+  afterEach(() => {
+    jest.clearAllTimers();
+  });
   describe('Health Check Endpoint', () => {
     it('should return healthy status', async () => {
       const response = await request(app).get('/health');
diff --git a/test/intentIdGenerator.test.js b/test/intentIdGenerator.test.js
new file mode 100644
index 0000000..18df69a
--- /dev/null
+++ b/test/intentIdGenerator.test.js
@@ -0,0 +1,61 @@
+const crypto = require('crypto');
+const IntentIdGenerator = require('../src/utils/intentIdGenerator');
+
+// Make random deterministic for parts we assert structurally
+jest.spyOn(crypto, 'randomBytes').mockImplementation(size =>
+  Buffer.from('a'.repeat(size))
+);
+
+describe('IntentIdGenerator', () => {
+  afterAll(() => {
+    jest.restoreAllMocks();
+  });
+
+  it('generate returns string with expected parts', () => {
+    const id = IntentIdGenerator.generate('dustZap', '0x1234567890abcdef1234567890abcdef12345678');
+    const parts = id.split('_');
+    expect(parts[0]).toBe('dustZap');
+    expect(Number.isFinite(Number(parts[1]))).toBe(true);
+    // last 6 chars of address
+    expect(parts[2]).toBe('345678');
+    expect(parts[3]).toMatch(/^[0-9a-f]+$/);
+  });
+
+  it('generateShort returns intentType_prefix with hex suffix', () => {
+    const id = IntentIdGenerator.generateShort('rebalance');
+    expect(id.startsWith('rebalance_')).toBe(true);
+    expect(id.split('_')[1]).toMatch(/^[0-9a-f]+$/);
+  });
+
+  it('validate checks basic format', () => {
+    expect(IntentIdGenerator.validate('')).toBe(false);
+    expect(IntentIdGenerator.validate(null)).toBe(false);
+    expect(IntentIdGenerator.validate('type_only')).toBe(true);
+    expect(IntentIdGenerator.validate('type_123_addr_rand')).toBe(true);
+  });
+
+  it('extractIntentType returns first segment or null', () => {
+    expect(IntentIdGenerator.extractIntentType('swap_123_abcdef_deadbeef')).toBe('swap');
+    expect(IntentIdGenerator.extractIntentType('')).toBeNull();
+  });
+
+  it('isExpired handles invalid and short IDs conservatively', () => {
+    expect(IntentIdGenerator.isExpired('')).toBe(true);
+    // short id (no timestamp) considered expired
+    expect(IntentIdGenerator.isExpired('type_abcd')).toBe(true);
+  });
+
+  it('isExpired returns based on timestamp vs maxAge', () => {
+    const now = Date.now();
+    jest.spyOn(Date, 'now').mockReturnValue(now);
+
+    const ts = now - 10_000; // 10s ago
+    const freshId = `swap_${ts}_abcdef_deadbeef`;
+    expect(IntentIdGenerator.isExpired(freshId, 60_000)).toBe(false);
+
+    const oldTs = now - 120_000; // 2m ago
+    const oldId = `swap_${oldTs}_abcdef_deadbeef`;
+    expect(IntentIdGenerator.isExpired(oldId, 60_000)).toBe(true);
+  });
+});
+
diff --git a/test/server-startup.test.js b/test/server-startup.test.js
index 7a6b7a3..f7ea194 100644
--- a/test/server-startup.test.js
+++ b/test/server-startup.test.js
@@ -11,6 +11,10 @@ describe('Server Startup', () => {
     });
 
     let output = '';
+    const timeoutId = setTimeout(() => {
+      child.kill();
+      done(new Error('Server startup test timed out'));
+    }, 5000);
 
     child.stdout.on('data', data => {
       output += data.toString();
@@ -26,7 +30,8 @@ describe('Server Startup', () => {
         output.includes('Supported DEX providers: 1inch, paraswap, 0x') &&
         output.includes('Supported intents: dustZap')
       ) {
-        // Kill the child process
+        // Clear timeout and kill the child process
+        clearTimeout(timeoutId);
         child.kill();
 
         // Test passed
@@ -39,14 +44,9 @@ describe('Server Startup', () => {
     });
 
     child.on('error', error => {
+      clearTimeout(timeoutId);
       done(error);
     });
-
-    // Timeout after 5 seconds
-    setTimeout(() => {
-      child.kill();
-      done(new Error('Server startup test timed out'));
-    }, 5000);
   });
 
   it('should use default port when PORT env is not set', done => {
@@ -61,13 +61,18 @@ describe('Server Startup', () => {
     });
 
     let output = '';
+    const timeoutId = setTimeout(() => {
+      child.kill();
+      done(new Error('Server startup test timed out'));
+    }, 5000);
 
     child.stdout.on('data', data => {
       output += data.toString();
 
       // Check if server started with default port
       if (output.includes('ðŸš€ Intent Engine Server running on port 3002')) {
-        // Kill the child process
+        // Clear timeout and kill the child process
+        clearTimeout(timeoutId);
         child.kill();
 
         // Test passed
@@ -80,13 +85,8 @@ describe('Server Startup', () => {
     });
 
     child.on('error', error => {
+      clearTimeout(timeoutId);
       done(error);
     });
-
-    // Timeout after 5 seconds
-    setTimeout(() => {
-      child.kill();
-      done(new Error('Server startup test timed out'));
-    }, 5000);
   });
 });
diff --git a/test/setup.js b/test/setup.js
index bd5c018..23a3976 100644
--- a/test/setup.js
+++ b/test/setup.js
@@ -121,12 +121,19 @@ afterAll(() => {
   // Clear all timers and intervals to prevent Jest from hanging
   jest.clearAllTimers();
 
+  // Clear all module cache to ensure cleanup of any singleton instances
+  Object.keys(require.cache).forEach(key => {
+    if (!key.includes('node_modules')) {
+      delete require.cache[key];
+    }
+  });
+
   // Force garbage collection if available (Node.js specific)
   if (global.gc) {
     global.gc();
   }
 
   if (isDebugMode) {
-    originalConsole.info('ðŸ§¹ Global cleanup: All timers cleared');
+    originalConsole.info('ðŸ§¹ Global cleanup: All timers cleared and modules cache cleaned');
   }
 });
diff --git a/test/smartFeeInsertionService.extra.test.js b/test/smartFeeInsertionService.extra.test.js
new file mode 100644
index 0000000..21a3df7
--- /dev/null
+++ b/test/smartFeeInsertionService.extra.test.js
@@ -0,0 +1,96 @@
+const SmartFeeInsertionService = require('../src/services/SmartFeeInsertionService');
+
+describe('SmartFeeInsertionService additional paths', () => {
+  let service;
+
+  beforeEach(() => {
+    service = new SmartFeeInsertionService();
+  });
+
+  it('shouldInsertFeeBlock uses first insertion point when available', () => {
+    const strategy = { insertionPoints: [5, 8], minimumThreshold: 3, strategy: 'random' };
+    expect(service.shouldInsertFeeBlock(4, strategy, 0, 0)).toBe(false);
+    expect(service.shouldInsertFeeBlock(5, strategy, 0, 0)).toBe(true);
+  });
+
+  it('shouldInsertFeeBlock with fallback uses progress threshold', () => {
+    const strategy = { insertionPoints: [], minimumThreshold: 7, strategy: 'fallback' };
+    // Needs >= 80% processed tokens
+    expect(service.shouldInsertFeeBlock(999, strategy, 7, 10)).toBe(false);
+    expect(service.shouldInsertFeeBlock(999, strategy, 8, 10)).toBe(true);
+  });
+
+  it('executeFeeBlockInsertion inserts block and reports position', () => {
+    const params = {
+      feeTransactions: [{ id: 'fee1' }, { id: 'fee2' }],
+      insertionStrategy: { insertionPoints: [2], minimumThreshold: 1, strategy: 'random' },
+      transactions: [{ id: 't1' }, { id: 't2' }],
+      currentTransactionCount: 2,
+      processedTokenCount: 0,
+      totalTokenCount: 0,
+    };
+
+    const res = service.executeFeeBlockInsertion(params);
+    expect(res.inserted).toBe(true);
+    expect(res.position).toBe(2);
+    expect(res.feeTransactionCount).toBe(2);
+    expect(params.transactions.slice(-2)).toEqual([{ id: 'fee1' }, { id: 'fee2' }]);
+  });
+
+  it('executeFeeBlockInsertion returns reason when not inserted', () => {
+    const params = {
+      feeTransactions: [],
+      insertionStrategy: { insertionPoints: [2], minimumThreshold: 1, strategy: 'random' },
+      transactions: [],
+      currentTransactionCount: 1,
+      processedTokenCount: 0,
+      totalTokenCount: 0,
+    };
+    const res = service.executeFeeBlockInsertion(params);
+    expect(res.inserted).toBe(false);
+    expect(res.reason).toMatch(/No fee transactions/);
+  });
+
+  it('executeFallbackFeeInsertion appends to end when provided', () => {
+    const params = {
+      feeTransactions: [{ id: 'fee1' }],
+      transactions: [{ id: 'a' }],
+    };
+    const res = service.executeFallbackFeeInsertion(params);
+    expect(res.inserted).toBe(true);
+    expect(res.position).toBe(1);
+    expect(params.transactions[1]).toEqual({ id: 'fee1' });
+  });
+
+  it('processFeeInsertion inserts up to available points', () => {
+    const params = {
+      shouldInsertFees: true,
+      insertionPoints: [1, 3],
+      currentTransactionIndex: 1,
+      feesInserted: 0,
+      feeTransactions: [{ id: 'fee1' }, { id: 'fee2' }],
+      results: { transactions: [{ id: 'x' }] },
+    };
+
+    const state = service.processFeeInsertion(params);
+    expect(state.feesInserted).toBe(2);
+    expect(state.currentTransactionIndex).toBe(3);
+    expect(state.insertionPoints).toEqual([]);
+    expect(params.results.transactions.slice(0, 3)).toEqual([
+      { id: 'x' },
+      { id: 'fee1' },
+      { id: 'fee2' },
+    ]);
+  });
+
+  it('insertRemainingFees appends leftover fees', () => {
+    const results = { transactions: [] };
+    service.insertRemainingFees({
+      shouldInsertFees: true,
+      feesInserted: 1,
+      feeTransactions: [{ id: 'f1' }, { id: 'f2' }],
+      results,
+    });
+    expect(results.transactions).toEqual([{ id: 'f2' }]);
+  });
+});
